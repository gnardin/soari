/* Generated By:JavaCC: Do not edit this line. SPARQLParser.java */
package otservices.translator.language.sparql.parser;

import java.util.ArrayList;
import java.util.List;
import otservices.translator.language.LanguageException;
import otservices.translator.language.LanguageInterface;
import otservices.translator.language.sparql.SPARQLObject;
import otservices.translator.language.sparql.LogExpr;
import otservices.translator.language.sparql.RegExpr;
import otservices.translator.language.sparql.RelExpr;
import otservices.translator.language.sparql.Term;
import otservices.translator.language.sparql.Result;
import otservices.translator.language.sparql.Where;
import otservices.translator.language.sparql.Filter;

public class SPARQLParser implements LanguageInterface, SPARQLParserConstants{
	
	private List<String>	concepts			= new ArrayList<String>();
	
	private Filter				filter				= new Filter();
	
	private String				message				= null;
	
	private SPARQLObject	parsedObject	= new SPARQLObject();
	
	private Result				result				= new Result();
	
	private Boolean				testResult		= new Boolean(false);
	
	private Where					where					= new Where();
	
	
	/**
	 *
	 */
	public SPARQLParser(String message){
		this.message = message;
		this.testResult = new Boolean(true);
	}
	
	
	/**
	 *
	 */
	@Override
	public Object getParsedObject(){
		return this.parsedObject;
	}
	
	
	/**
	 *
	 */
	@Override
	public void run() throws LanguageException{
		if(testResult.booleanValue()){
			this.result.setXML(this.message);
			this.parsedObject.setCommand(SPARQLObject.Command.RESULT);
			this.parsedObject.addResult(this.result);
		}else{
			try{
				this.parse();
				
				this.parsedObject.addConcepts(this.concepts);
				this.parsedObject.addResult(this.result);
				this.parsedObject.addWhere(this.where);
				this.parsedObject.addFilter(this.filter);
			}catch(ParseException pe){
				throw new LanguageException(pe.getMessage());
			}
		}
	}
	
	
	/**
	 *
	 */
	@Override
	public void setParsedObject(Object parsedObject){
		if(parsedObject instanceof SPARQLObject){
			this.parsedObject = (SPARQLObject) parsedObject;
		}
	}
	
	
	final public void parse() throws ParseException{
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
			case SELECT:
				select();
				this.parsedObject.setCommand(SPARQLObject.Command.SELECT);
				break;
			case UPDATE:
				update();
				this.parsedObject.setCommand(SPARQLObject.Command.UPDATE);
				jj_consume_token(0);
				break;
			default:
				jj_la1[0] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}
	
	
	final public void select() throws ParseException{
		jj_consume_token(SELECT);
		vars();
		where();
	}
	
	
	final public void vars() throws ParseException{
		Token var;
		var = jj_consume_token(VAR);
		this.result.addResult(var.image);
		label_1: while(true){
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
				case VAR:
					;
					break;
				default:
					jj_la1[1] = jj_gen;
					break label_1;
			}
			var = jj_consume_token(VAR);
			this.result.addResult(var.image);
		}
	}
	
	
	final public void where() throws ParseException{
		jj_consume_token(WHERE);
		jj_consume_token(23);
		triplesBlock();
		jj_consume_token(24);
	}
	
	
	final public void triplesBlock() throws ParseException{
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
			case VAR:
				triplesSameSubject();
				break;
			case FILTER:
				filter();
				break;
			default:
				jj_la1[2] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		label_2: while(true){
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
				case FILTER:
				case VAR:
					;
					break;
				default:
					jj_la1[3] = jj_gen;
					break label_2;
			}
			triplesBlock();
		}
	}
	
	
	final public void triplesSameSubject() throws ParseException{
		Token concept;
		Token var;
		jj_consume_token(VAR);
		jj_consume_token(STRING);
		jj_consume_token(25);
		concept = jj_consume_token(STRING);
		var = jj_consume_token(VAR);
		jj_consume_token(26);
		this.concepts.add(concept.image.toLowerCase());
		this.where.addWhere(var.image, concept.image.toLowerCase());
	}
	
	
	final public void filter() throws ParseException{
		jj_consume_token(FILTER);
		constraint();
	}
	
	
	final public void constraint() throws ParseException{
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
			case 27:
				brackettedExpression();
				break;
			case REGEX:
				regex();
				break;
			default:
				jj_la1[4] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}
	
	
	final public void brackettedExpression() throws ParseException{
		jj_consume_token(27);
		conditionalOrExpression();
		jj_consume_token(28);
	}
	
	
	final public void conditionalOrExpression() throws ParseException{
		LogExpr logExpr;
		conditionalAndExpression();
		label_3: while(true){
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
				case 29:
					;
					break;
				default:
					jj_la1[5] = jj_gen;
					break label_3;
			}
			jj_consume_token(29);
			conditionalOrExpression();
			logExpr = new LogExpr();
			logExpr.setLogicalOp(LogExpr.LogicalOp.OR);
			this.filter.addItem(logExpr);
		}
	}
	
	
	final public void conditionalAndExpression() throws ParseException{
		LogExpr logExpr;
		valueLogical();
		label_4: while(true){
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
				case 30:
					;
					break;
				default:
					jj_la1[6] = jj_gen;
					break label_4;
			}
			jj_consume_token(30);
			valueLogical();
			logExpr = new LogExpr();
			logExpr.setLogicalOp(LogExpr.LogicalOp.AND);
			this.filter.addItem(logExpr);
		}
	}
	
	
	final public void valueLogical() throws ParseException{
		RelExpr relExpr;
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
			case 27:
				brackettedExpression();
				break;
			case REGEX:
				regex();
				break;
			case BOOL:
			case VAR:
			case INT:
			case FLOAT:
			case INTP:
			case INTN:
			case FLOATP:
			case FLOATN:
			case STRING:
				term(1);
				label_5: while(true){
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
						case 31:
						case 32:
						case 33:
						case 34:
						case 35:
						case 36:
							;
							break;
						default:
							jj_la1[7] = jj_gen;
							break label_5;
					}
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
						case 31:
							jj_consume_token(31);
							term(2);
							relExpr = new RelExpr();
							relExpr.setRelationalOp(RelExpr.RelationalOp.LT);
							this.filter.addItem(relExpr);
							break;
						case 32:
							jj_consume_token(32);
							term(2);
							relExpr = new RelExpr();
							relExpr.setRelationalOp(RelExpr.RelationalOp.GT);
							this.filter.addItem(relExpr);
							break;
						case 33:
							jj_consume_token(33);
							term(2);
							relExpr = new RelExpr();
							relExpr.setRelationalOp(RelExpr.RelationalOp.EQ);
							this.filter.addItem(relExpr);
							break;
						case 34:
							jj_consume_token(34);
							term(2);
							relExpr = new RelExpr();
							relExpr.setRelationalOp(RelExpr.RelationalOp.DIF);
							this.filter.addItem(relExpr);
							break;
						case 35:
							jj_consume_token(35);
							term(2);
							relExpr = new RelExpr();
							relExpr.setRelationalOp(RelExpr.RelationalOp.LTE);
							this.filter.addItem(relExpr);
							break;
						case 36:
							jj_consume_token(36);
							term(2);
							relExpr = new RelExpr();
							relExpr.setRelationalOp(RelExpr.RelationalOp.GTE);
							this.filter.addItem(relExpr);
							break;
						default:
							jj_la1[8] = jj_gen;
							jj_consume_token(-1);
							throw new ParseException();
					}
				}
				break;
			default:
				jj_la1[9] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}
	
	
	final public void term(int position) throws ParseException{
		Token t;
		Term term = new Term();
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
			case INT:
				term = new Term();
				t = jj_consume_token(INT);
				term.setType(Term.TermType.INTEGER);
				term.setTerm(new Integer(t.image));
				if(position == 1){
					term.setPosition(Term.Position.FIRST);
				}else if(position == 2){
					term.setPosition(Term.Position.SECOND);
				}
				this.filter.addItem(term);
				break;
			case INTP:
				t = jj_consume_token(INTP);
				term.setType(Term.TermType.INTEGER);
				term.setTerm(new Integer(t.image));
				if(position == 1){
					term.setPosition(Term.Position.FIRST);
				}else if(position == 2){
					term.setPosition(Term.Position.SECOND);
				}
				this.filter.addItem(term);
				break;
			case INTN:
				t = jj_consume_token(INTN);
				term.setType(Term.TermType.INTEGER);
				term.setTerm(new Integer(t.image));
				if(position == 1){
					term.setPosition(Term.Position.FIRST);
				}else if(position == 2){
					term.setPosition(Term.Position.SECOND);
				}
				this.filter.addItem(term);
				break;
			case FLOAT:
				t = jj_consume_token(FLOAT);
				term.setType(Term.TermType.FLOAT);
				term.setTerm(new Float(t.image));
				if(position == 1){
					term.setPosition(Term.Position.FIRST);
				}else if(position == 2){
					term.setPosition(Term.Position.SECOND);
				}
				this.filter.addItem(term);
				break;
			case FLOATP:
				t = jj_consume_token(FLOATP);
				term.setType(Term.TermType.FLOAT);
				term.setTerm(new Float(t.image));
				if(position == 1){
					term.setPosition(Term.Position.FIRST);
				}else if(position == 2){
					term.setPosition(Term.Position.SECOND);
				}
				this.filter.addItem(term);
				break;
			case FLOATN:
				t = jj_consume_token(FLOATN);
				term.setType(Term.TermType.FLOAT);
				term.setTerm(new Float(t.image));
				if(position == 1){
					term.setPosition(Term.Position.FIRST);
				}else if(position == 2){
					term.setPosition(Term.Position.SECOND);
				}
				this.filter.addItem(term);
				break;
			case BOOL:
				t = jj_consume_token(BOOL);
				term.setType(Term.TermType.BOOLEAN);
				term.setTerm(new Boolean(t.image));
				if(position == 1){
					term.setPosition(Term.Position.FIRST);
				}else if(position == 2){
					term.setPosition(Term.Position.SECOND);
				}
				this.filter.addItem(term);
				break;
			case STRING:
				t = jj_consume_token(STRING);
				term.setType(Term.TermType.STRING);
				term.setTerm(t.image);
				if(position == 1){
					term.setPosition(Term.Position.FIRST);
				}else if(position == 2){
					term.setPosition(Term.Position.SECOND);
				}
				this.filter.addItem(term);
				break;
			case VAR:
				t = jj_consume_token(VAR);
				term.setType(Term.TermType.VARIABLE);
				term.setTerm(t.image);
				if(position == 1){
					term.setPosition(Term.Position.FIRST);
				}else if(position == 2){
					term.setPosition(Term.Position.SECOND);
				}
				this.filter.addItem(term);
				break;
			default:
				jj_la1[10] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}
	
	
	final public void regex() throws ParseException{
		Token var = null;
		Token pattern = null;
		RegExpr regExpr;
		regExpr = new RegExpr();
		jj_consume_token(REGEX);
		jj_consume_token(27);
		var = jj_consume_token(VAR);
		jj_consume_token(37);
		pattern = jj_consume_token(STRING);
		jj_consume_token(28);
		regExpr.setVariable(var.image);
		regExpr.setPattern(pattern.image);
		this.filter.addItem(regExpr);
	}
	
	
	final public void update() throws ParseException{
		jj_consume_token(UPDATE);
		sets();
		where();
	}
	
	
	final public void sets() throws ParseException{
		Token t;
		Token v;
		Term term;
		label_6: while(true){
			term = new Term();
			t = jj_consume_token(VAR);
			jj_consume_token(33);
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
				case INT:
					v = jj_consume_token(INT);
					term.setType(Term.TermType.INTEGER);
					term.setTerm(new Integer(v.image));
					break;
				case INTP:
					v = jj_consume_token(INTP);
					term.setType(Term.TermType.INTEGER);
					term.setTerm(new Integer(v.image));
					break;
				case INTN:
					v = jj_consume_token(INTN);
					term.setType(Term.TermType.INTEGER);
					term.setTerm(new Integer(v.image));
					break;
				case FLOAT:
					v = jj_consume_token(FLOAT);
					term.setType(Term.TermType.FLOAT);
					term.setTerm(new Float(v.image));
					break;
				case FLOATP:
					v = jj_consume_token(FLOATP);
					term.setType(Term.TermType.FLOAT);
					term.setTerm(new Float(v.image));
					break;
				case FLOATN:
					v = jj_consume_token(FLOATN);
					term.setType(Term.TermType.FLOAT);
					term.setTerm(new Float(v.image));
					break;
				case BOOL:
					v = jj_consume_token(BOOL);
					term.setType(Term.TermType.BOOLEAN);
					term.setTerm(new Boolean(v.image));
					break;
				case STRING:
					v = jj_consume_token(STRING);
					term.setType(Term.TermType.STRING);
					term.setTerm(new String(v.image));
					break;
				default:
					jj_la1[11] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			this.result.addResult(t.image, term);
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk){
				case VAR:
					;
					break;
				default:
					jj_la1[12] = jj_gen;
					break label_6;
			}
		}
	}
	
	/** Generated Token Manager. */
	public SPARQLParserTokenManager	token_source;
	
	SimpleCharStream								jj_input_stream;
	
	/** Current token. */
	public Token										token;
	
	/** Next token. */
	public Token										jj_nt;
	
	private int											jj_ntk;
	
	private int											jj_gen;
	
	final private int[]							jj_la1	= new int[13];
	
	static private int[]						jj_la1_0;
	
	static private int[]						jj_la1_1;
	static{
		jj_la1_init_0();
		jj_la1_init_1();
	}
	
	
	private static void jj_la1_init_0(){
		jj_la1_0 = new int[]{0x60, 0x800, 0x900, 0x900, 0x8000200, 0x20000000,
				0x40000000, 0x80000000, 0x80000000, 0x81fce00, 0x1fcc00, 0x1fc400,
				0x800,};
	}
	
	
	private static void jj_la1_init_1(){
		jj_la1_1 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x1f, 0x0,
				0x0, 0x0, 0x0,};
	}
	
	
	/** Constructor with InputStream. */
	public SPARQLParser(java.io.InputStream stream){
		this(stream, null);
	}
	
	
	/** Constructor with InputStream and supplied encoding */
	public SPARQLParser(java.io.InputStream stream, String encoding){
		try{
			jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
		}catch(java.io.UnsupportedEncodingException e){
			throw new RuntimeException(e);
		}
		token_source = new SPARQLParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 13; i++)
			jj_la1[i] = -1;
	}
	
	
	/** Reinitialise. */
	public void ReInit(java.io.InputStream stream){
		ReInit(stream, null);
	}
	
	
	/** Reinitialise. */
	public void ReInit(java.io.InputStream stream, String encoding){
		try{
			jj_input_stream.ReInit(stream, encoding, 1, 1);
		}catch(java.io.UnsupportedEncodingException e){
			throw new RuntimeException(e);
		}
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 13; i++)
			jj_la1[i] = -1;
	}
	
	
	/** Constructor. */
	public SPARQLParser(java.io.Reader stream){
		jj_input_stream = new SimpleCharStream(stream, 1, 1);
		token_source = new SPARQLParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 13; i++)
			jj_la1[i] = -1;
	}
	
	
	/** Reinitialise. */
	public void ReInit(java.io.Reader stream){
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 13; i++)
			jj_la1[i] = -1;
	}
	
	
	/** Constructor with generated Token Manager. */
	public SPARQLParser(SPARQLParserTokenManager tm){
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 13; i++)
			jj_la1[i] = -1;
	}
	
	
	/** Reinitialise. */
	public void ReInit(SPARQLParserTokenManager tm){
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 13; i++)
			jj_la1[i] = -1;
	}
	
	
	private Token jj_consume_token(int kind) throws ParseException{
		Token oldToken;
		if((oldToken = token).next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if(token.kind == kind){
			jj_gen++;
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}
	
	
	/** Get the next Token. */
	final public Token getNextToken(){
		if(token.next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		return token;
	}
	
	
	/** Get the specific Token. */
	final public Token getToken(int index){
		Token t = token;
		for(int i = 0; i < index; i++){
			if(t.next != null)
				t = t.next;
			else
				t = t.next = token_source.getNextToken();
		}
		return t;
	}
	
	
	private int jj_ntk(){
		if((jj_nt = token.next) == null)
			return(jj_ntk = (token.next = token_source.getNextToken()).kind);
		else
			return(jj_ntk = jj_nt.kind);
	}
	
	private java.util.List<int[]>	jj_expentries	= new java.util.ArrayList<int[]>();
	
	private int[]									jj_expentry;
	
	private int										jj_kind				= -1;
	
	
	/** Generate ParseException. */
	public ParseException generateParseException(){
		jj_expentries.clear();
		boolean[] la1tokens = new boolean[38];
		if(jj_kind >= 0){
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for(int i = 0; i < 13; i++){
			if(jj_la1[i] == jj_gen){
				for(int j = 0; j < 32; j++){
					if((jj_la1_0[i] & (1 << j)) != 0){
						la1tokens[j] = true;
					}
					if((jj_la1_1[i] & (1 << j)) != 0){
						la1tokens[32 + j] = true;
					}
				}
			}
		}
		for(int i = 0; i < 38; i++){
			if(la1tokens[i]){
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.add(jj_expentry);
			}
		}
		int[][] exptokseq = new int[jj_expentries.size()][];
		for(int i = 0; i < jj_expentries.size(); i++){
			exptokseq[i] = jj_expentries.get(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}
	
	
	/** Enable tracing. */
	final public void enable_tracing(){
	}
	
	
	/** Disable tracing. */
	final public void disable_tracing(){
	}
	
}
